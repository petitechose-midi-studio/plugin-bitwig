/**
 * Protocol.hpp.template - Serial8 Protocol Handler Template
 *
 * ============================================================================
 * HOW TO USE THIS TEMPLATE
 * ============================================================================
 *
 * 1. Copy this file to your project as Protocol.hpp (remove .template)
 * 2. Replace YOUR_TRANSPORT_TYPE with your actual transport
 * 3. Implement send() and dispatch() for your transport
 * 4. Add any project-specific helper methods
 *
 * This template is NOT compiled directly. It provides the structure and
 * includes you need to create your Protocol class.
 *
 * ============================================================================
 * TRANSPORT EXAMPLES
 * ============================================================================
 *
 * Serial8 over USB Serial (Teensy):
 *   - Transport: oc::hal::ISerialTransport& (UsbSerial)
 *   - Framing: COBS (handled by transport)
 *   - Header: [MessageID][payload...]
 *
 * Serial8 over TCP Socket:
 *   - Transport: TcpSocket& or similar
 *   - Framing: Length-prefix or COBS
 *   - Header: [MessageID][payload...]
 *
 * SysEx over MIDI:
 *   - Transport: oc::api::MidiAPI& + EventBus
 *   - Framing: F0 ... F7
 *   - Header: [F0][MFR][DEV][MessageID][payload...][F7]
 *
 * ============================================================================
 */

#pragma once

// ============================================================================
// Required Includes (DO NOT REMOVE)
// ============================================================================

#include "MessageID.hpp"
#include "ProtocolConstants.hpp"
#include "ProtocolCallbacks.hpp"
#include "DecoderRegistry.hpp"
#include "MessageStructure.hpp"  // All message types

#include <cstdint>
#include <cstring>

// ============================================================================
// TODO: Add your transport include here
// ============================================================================
// Examples:
//   #include <oc/hal/ISerialTransport.hpp>  // For Serial8 over USB
//   #include <oc/api/MidiAPI.hpp>           // For SysEx over MIDI
//   #include "TcpSocket.hpp"                // For TCP socket

namespace Protocol {

/**
 * Serial8 Protocol Handler
 *
 * TODO: Customize this class for your transport layer.
 *
 * Inherits from ProtocolCallbacks which provides typed callback members
 * for each message type (e.g., onSensorReading, onLog, etc.)
 */
class Protocol : public ProtocolCallbacks {
public:
    // ========================================================================
    // TODO: Constructor - adapt to your transport
    // ========================================================================

    /**
     * Example for ISerialTransport:
     *
     *   explicit Protocol(oc::hal::ISerialTransport& transport)
     *       : transport_(transport)
     *   {
     *       transport_.setOnReceive([this](const uint8_t* data, size_t len) {
     *           dispatch(data, len);
     *       });
     *   }
     *
     * Example for MidiAPI + EventBus:
     *
     *   Protocol(oc::api::MidiAPI& midi, oc::core::event::IEventBus& events)
     *       : midi_(midi), events_(events)
     *   {
     *       subscriptionId_ = events_.on(EventCategory::MIDI, MidiEvent::SYSEX,
     *           [this](const Event& evt) {
     *               const auto& sysex = static_cast<const SysExEvent&>(evt);
     *               dispatch(sysex.data, sysex.length);
     *           });
     *   }
     */

    // Non-copyable
    Protocol(const Protocol&) = delete;
    Protocol& operator=(const Protocol&) = delete;

    // ========================================================================
    // Send API
    // ========================================================================

    /**
     * Send a typed message
     *
     * TODO: Implement for your transport.
     *
     * @tparam T Message type (has MESSAGE_ID and encode())
     * @param message Message to send
     */
    template<typename T>
    void send(const T& message) {
        // Build frame: [MessageID][payload...]
        uint8_t frame[ProtocolConstants::MAX_MESSAGE_SIZE];
        size_t offset = 0;

        // Header
        frame[offset++] = static_cast<uint8_t>(T::MESSAGE_ID);

        // Payload
        uint8_t payload[T::MAX_PAYLOAD_SIZE];
        size_t payloadLen = message.encode(payload);
        std::memcpy(frame + offset, payload, payloadLen);
        offset += payloadLen;

        // TODO: Send via your transport
        // Examples:
        //   transport_.send(frame, offset);           // ISerialTransport
        //   midi_.sendSysEx(buildSysEx(frame, offset)); // MidiAPI
        //   socket_.write(frame, offset);             // TCP
    }

    // ========================================================================
    // Receive / Dispatch
    // ========================================================================

    /**
     * Dispatch incoming frame to appropriate callback
     *
     * Called by your transport's receive callback.
     *
     * @param data Frame data (after transport-specific decoding)
     * @param len Frame length
     */
    void dispatch(const uint8_t* data, size_t len) {
        if (len < ProtocolConstants::MIN_MESSAGE_LENGTH) {
            return;  // Frame too short
        }

        // Parse header
        auto messageId = static_cast<MessageID>(data[ProtocolConstants::MESSAGE_TYPE_OFFSET]);

        // Extract payload
        const uint8_t* payload = data + ProtocolConstants::PAYLOAD_OFFSET;
        size_t payloadLen = len - ProtocolConstants::PAYLOAD_OFFSET;

        // Dispatch to typed callback (inherited from ProtocolCallbacks)
        DecoderRegistry::dispatch(*this, messageId, payload, payloadLen);
    }

    // ========================================================================
    // TODO: Add project-specific helper methods here
    // ========================================================================
    // Examples:
    //   void requestHostStatus();
    //   void selectDevice(uint8_t index);
    //   void sendParameterValue(uint8_t index, float value);

private:
    // ========================================================================
    // TODO: Add your transport member(s) here
    // ========================================================================
    // Examples:
    //   oc::hal::ISerialTransport& transport_;
    //   oc::api::MidiAPI& midi_;
    //   oc::core::event::IEventBus& events_;
    //   oc::core::event::SubscriptionID subscriptionId_{0};
};

}  // namespace Protocol

// ============================================================================
// USAGE EXAMPLE
// ============================================================================
//
// #include "Protocol.hpp"
// #include <oc/teensy/UsbSerial.hpp>
//
// oc::teensy::UsbSerial serial;
// Protocol::Protocol protocol(serial);
//
// void setup() {
//     serial.init();
//
//     // Register callbacks
    // protocol.onDeviceChange = [](const DeviceChangeMessage& msg) { };
    // protocol.onDeviceChangeHeader = [](const DeviceChangeHeaderMessage& msg) { };
    // protocol.onDeviceChildren = [](const DeviceChildrenMessage& msg) { };
// }
//
// void loop() {
//     serial.update();  // Polls and dispatches incoming messages
//
//     // Send messages
//     // protocol.send(SensorReadingMessage{...});
// }
