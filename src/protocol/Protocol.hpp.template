/**
 * Protocol.hpp.template - Protocol Handler Template
 *
 * AUTO-GENERATED - Customize for your project
 */

#pragma once

#include <cstdint>
#include <cstring>

#include "MessageID.hpp"
#include "ProtocolConstants.hpp"
#include "ProtocolCallbacks.hpp"
#include "DecoderRegistry.hpp"
#include "MessageStructure.hpp"
#include <oc/hal/ISerialTransport.hpp>

namespace Protocol {

class Protocol : public ProtocolCallbacks {
public:
    explicit Protocol(oc::hal::ISerialTransport& transport)
        : transport_(transport) {
        transport_.setOnReceive([this](const uint8_t* data, size_t len) {
            dispatch(data, len);
        });
    }

    ~Protocol() = default;

    // Non-copyable, non-movable
    Protocol(const Protocol&) = delete;
    Protocol& operator=(const Protocol&) = delete;
    Protocol(Protocol&&) = delete;
    Protocol& operator=(Protocol&&) = delete;

#include "ProtocolMethods.inl"
    template <typename T>
    void send(const T& message) {
        constexpr MessageID messageId = T::MESSAGE_ID;

        // Encode payload
        uint8_t payload[T::MAX_PAYLOAD_SIZE];
        uint16_t payloadLen = message.encode(payload, sizeof(payload));

        // Build frame
        uint8_t frame[MAX_MESSAGE_SIZE];
        uint16_t offset = 0;
        using Protocol::MAX_MESSAGE_SIZE;
        using Protocol::MESSAGE_TYPE_OFFSET;
        using Protocol::PAYLOAD_OFFSET;

        // Serial8 frame: [MessageID][payload...]
        frame[offset++] = static_cast<uint8_t>(messageId);
        std::memcpy(frame + offset, payload, payloadLen);
        offset += payloadLen;

        // Send frame
        transport_.send(frame, offset);
    }

    void dispatch(const uint8_t* data, size_t len) {
        if (data == nullptr || len < MIN_MESSAGE_LENGTH) {
            return;
        }

        MessageID messageId = static_cast<MessageID>(data[MESSAGE_TYPE_OFFSET]);
        uint16_t payloadLen = len - PAYLOAD_OFFSET;
        const uint8_t* payload = data + PAYLOAD_OFFSET;

        DecoderRegistry::dispatch(*this, messageId, payload, payloadLen);
    }

private:
    oc::hal::ISerialTransport& transport_;
};

}  // namespace Protocol

// ============================================================================
// USAGE EXAMPLE
// ============================================================================
//
// Protocol protocol(...);
//
// // Register callbacks
// protocol.onDeviceChange = [](const DeviceChangeMessage& msg) { };
// protocol.onDeviceChangeHeader = [](const DeviceChangeHeaderMessage& msg) { };
// protocol.onDeviceChildren = [](const DeviceChildrenMessage& msg) { };
//
// // Send messages
// protocol.send(DevicePageSelectMessage{...});
// protocol.send(DeviceRemoteControlRestoreAutomationMessage{...});
// protocol.send(DeviceRemoteControlTouchMessage{...});
